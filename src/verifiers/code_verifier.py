"""
Code execution verifier for RLVR.

This module implements a verifier that executes generated code and checks
if the outputs match expected results. It supports various programming
languages and provides safety measures for code execution.
"""

import ast
import subprocess
import tempfile
import time
import traceback
from typing import Dict, Any, List, Optional, Union, Tuple
from pathlib import Path
import logging
import re
import json
from io import StringIO
import sys

from .base_verifier import BaseVerifier, VerificationOutput, VerificationResult


class CodeVerifier(BaseVerifier):
    """
    Verifier that executes generated code and verifies outputs.
    
    This verifier can handle various programming languages and provides
    safety measures to prevent malicious code execution.
    """
    
    def __init__(
        self,
        name: str = "code_verifier",
        config: Optional[Dict[str, Any]] = None,
        logger: Optional[logging.Logger] = None
    ):
        """
        Initialize the code verifier.
        
        Args:
            name: Name of the verifier
            config: Configuration parameters
            logger: Logger instance
        """
        default_config = {
            "timeout": 30,  # Execution timeout in seconds
            "allowed_languages": ["python", "javascript", "bash"],
            "max_output_size": 10000,  # Maximum output size in characters
            "safe_mode": True,  # Enable safety restrictions
            "allowed_modules": ["math", "random", "datetime", "json", "re"],
            "forbidden_keywords": [
                "import os", "import sys", "import subprocess", "eval", "exec",
                "__import__", "open", "file", "input", "raw_input"
            ],
            "test_cases": [],  # Additional test cases
            "output_format": "text"  # Expected output format
        }
        
        if config:
            default_config.update(config)
        
        super().__init__(
            name=name,
            description="Executes generated code and verifies outputs",
            config=default_config,
            logger=logger
        )
    
    def _validate_config(self) -> None:
        """Validate the verifier configuration."""
        if self.config["timeout"] <= 0:
            raise ValueError("Timeout must be positive")
        
        if self.config["max_output_size"] <= 0:
            raise ValueError("Max output size must be positive")
        
        if not isinstance(self.config["allowed_languages"], list):
            raise ValueError("Allowed languages must be a list")
    
    def verify(
        self,
        instruction: str,
        model_output: str,
        expected_output: Optional[str] = None,
        context: Optional[Dict[str, Any]] = None
    ) -> VerificationOutput:
        """
        Verify code execution and output correctness.
        
        Args:
            instruction: The instruction given to the model
            model_output: The code generated by the model
            expected_output: Expected output (if available)
            context: Additional context for verification
            
        Returns:
            VerificationOutput: Structured verification result
        """
        start_time = time.time()
        
        try:
            # Extract code from model output
            code = self._extract_code(model_output, context)
            if not code:
                return VerificationOutput(
                    result=VerificationResult.INCORRECT,
                    score=0.0,
                    details={"error": "No code found in model output"},
                    error_message="No code found in model output"
                )
            
            # Validate code safety
            safety_check = self._check_code_safety(code)
            if not safety_check["safe"]:
                return VerificationOutput(
                    result=VerificationResult.ERROR,
                    score=0.0,
                    details=safety_check,
                    error_message=safety_check["reason"]
                )
            
            # Execute code
            execution_result = self._execute_code(code, context)
            
            # Verify output
            verification_result = self._verify_output(
                execution_result, expected_output, context
            )
            
            execution_time = time.time() - start_time
            
            return VerificationOutput(
                result=verification_result["result"],
                score=verification_result["score"],
                details={
                    "execution_output": execution_result["output"],
                    "execution_error": execution_result.get("error"),
                    "verification_details": verification_result["details"],
                    "code": code,
                    "execution_time": execution_time
                },
                execution_time=execution_time
            )
            
        except Exception as e:
            execution_time = time.time() - start_time
            self.logger.error(f"Verification failed: {e}")
            return VerificationOutput(
                result=VerificationResult.ERROR,
                score=0.0,
                details={"error": str(e), "traceback": traceback.format_exc()},
                error_message=str(e),
                execution_time=execution_time
            )
    
    def _extract_code(self, model_output: str, context: Optional[Dict[str, Any]] = None) -> str:
        """
        Extract code from model output.
        
        Args:
            model_output: The output from the model
            context: Additional context
            
        Returns:
            Extracted code string
        """
        # Try to find code blocks
        code_patterns = [
            r"```(?:python|javascript|bash|js)?\n(.*?)\n```",
            r"```\n(.*?)\n```",
            r"`(.*?)`",
        ]
        
        for pattern in code_patterns:
            matches = re.findall(pattern, model_output, re.DOTALL)
            if matches:
                return matches[0].strip()
        
        # If no code blocks found, assume the entire output is code
        # but only if it looks like code
        lines = model_output.strip().split('\n')
        if len(lines) > 1 or any(line.strip().startswith(('def ', 'import ', 'print(', 'if ', 'for ', 'while ')) for line in lines):
            return model_output.strip()
        
        return ""
    
    def _check_code_safety(self, code: str) -> Dict[str, Any]:
        """
        Check if the code is safe to execute.
        
        Args:
            code: Code to check
            
        Returns:
            Safety check result
        """
        if not self.config["safe_mode"]:
            return {"safe": True, "reason": "Safe mode disabled"}
        
        # Check for forbidden keywords
        code_lower = code.lower()
        for keyword in self.config["forbidden_keywords"]:
            if keyword.lower() in code_lower:
                return {
                    "safe": False,
                    "reason": f"Forbidden keyword found: {keyword}"
                }
        
        # Check for dangerous imports
        try:
            tree = ast.parse(code)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        if alias.name not in self.config["allowed_modules"]:
                            return {
                                "safe": False,
                                "reason": f"Forbidden import: {alias.name}"
                            }
                elif isinstance(node, ast.ImportFrom):
                    if node.module not in self.config["allowed_modules"]:
                        return {
                            "safe": False,
                            "reason": f"Forbidden import: {node.module}"
                        }
        except SyntaxError:
            # If we can't parse it, be conservative
            return {
                "safe": False,
                "reason": "Code contains syntax errors"
            }
        
        return {"safe": True, "reason": "Code passed safety checks"}
    
    def _execute_code(self, code: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Execute the code safely.
        
        Args:
            code: Code to execute
            context: Additional context
            
        Returns:
            Execution result
        """
        # For now, we'll focus on Python execution
        # This can be extended to support other languages
        
        try:
            # Create a safe execution environment
            safe_globals = {
                "__builtins__": {
                    "print": print,
                    "len": len,
                    "range": range,
                    "str": str,
                    "int": int,
                    "float": float,
                    "list": list,
                    "dict": dict,
                    "set": set,
                    "tuple": tuple,
                    "bool": bool,
                    "abs": abs,
                    "max": max,
                    "min": min,
                    "sum": sum,
                    "round": round,
                    "pow": pow,
                    "divmod": divmod,
                    "all": all,
                    "any": any,
                    "enumerate": enumerate,
                    "zip": zip,
                    "map": map,
                    "filter": filter,
                    "sorted": sorted,
                    "reversed": reversed,
                }
            }
            
            # Add allowed modules
            for module_name in self.config["allowed_modules"]:
                try:
                    module = __import__(module_name)
                    safe_globals[module_name] = module
                except ImportError:
                    pass
            
            # Add context variables
            if context:
                safe_globals.update(context)
            
            # Capture output
            output_buffer = StringIO()
            original_stdout = sys.stdout
            sys.stdout = output_buffer
            
            try:
                # Execute with timeout
                import signal
                
                def timeout_handler(signum, frame):
                    raise TimeoutError("Code execution timed out")
                
                signal.signal(signal.SIGALRM, timeout_handler)
                signal.alarm(self.config["timeout"])
                
                exec(code, safe_globals)
                
                signal.alarm(0)  # Cancel the alarm
                
                output = output_buffer.getvalue()
                
                # Check output size
                if len(output) > self.config["max_output_size"]:
                    output = output[:self.config["max_output_size"]] + "... (truncated)"
                
                return {
                    "output": output,
                    "globals": {k: v for k, v in safe_globals.items() if not k.startswith('_')}
                }
                
            except TimeoutError:
                return {
                    "output": "",
                    "error": "Execution timed out"
                }
            finally:
                sys.stdout = original_stdout
                output_buffer.close()
                
        except Exception as e:
            return {
                "output": "",
                "error": str(e)
            }
    
    def _verify_output(
        self,
        execution_result: Dict[str, Any],
        expected_output: Optional[str],
        context: Optional[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Verify the execution output against expected results.
        
        Args:
            execution_result: Result from code execution
            expected_output: Expected output
            context: Additional context
            
        Returns:
            Verification result
        """
        if execution_result.get("error"):
            return {
                "result": VerificationResult.ERROR,
                "score": 0.0,
                "details": {"execution_error": execution_result["error"]}
            }
        
        output = execution_result["output"]
        
        # If no expected output provided, check if output is non-empty
        if expected_output is None:
            if output.strip():
                return {
                    "result": VerificationResult.CORRECT,
                    "score": 1.0,
                    "details": {"output_generated": True}
                }
            else:
                return {
                    "result": VerificationResult.INCORRECT,
                    "score": 0.0,
                    "details": {"output_generated": False}
                }
        
        # Compare with expected output
        output_clean = output.strip()
        expected_clean = expected_output.strip()
        
        if output_clean == expected_clean:
            return {
                "result": VerificationResult.CORRECT,
                "score": 1.0,
                "details": {"exact_match": True}
            }
        
        # Try partial matching
        if expected_clean in output_clean or output_clean in expected_clean:
            return {
                "result": VerificationResult.PARTIAL,
                "score": 0.7,
                "details": {"partial_match": True}
            }
        
        # Try numerical comparison
        try:
            output_num = float(output_clean)
            expected_num = float(expected_clean)
            if abs(output_num - expected_num) < 1e-6:
                return {
                    "result": VerificationResult.CORRECT,
                    "score": 1.0,
                    "details": {"numerical_match": True}
                }
        except ValueError:
            pass
        
        return {
            "result": VerificationResult.INCORRECT,
            "score": 0.0,
            "details": {
                "expected": expected_clean,
                "actual": output_clean
            }
        }
    
    def add_test_case(self, input_data: str, expected_output: str) -> None:
        """
        Add a test case for verification.
        
        Args:
            input_data: Input data for the test case
            expected_output: Expected output
        """
        self.config["test_cases"].append({
            "input": input_data,
            "expected": expected_output
        })
    
    def run_test_cases(self, code: str) -> List[Dict[str, Any]]:
        """
        Run all test cases against the code.
        
        Args:
            code: Code to test
            
        Returns:
            List of test results
        """
        results = []
        
        for test_case in self.config["test_cases"]:
            context = {"input": test_case["input"]}
            execution_result = self._execute_code(code, context)
            verification_result = self._verify_output(
                execution_result, test_case["expected"], context
            )
            
            results.append({
                "test_case": test_case,
                "execution_result": execution_result,
                "verification_result": verification_result
            })
        
        return results 